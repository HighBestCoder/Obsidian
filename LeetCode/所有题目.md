
48. 图像旋转 #上下翻转再对角线翻转
49. 字母异位词分组  #哈希 
50. pow的实现 #位运算 #先乘再翻倍
51. N皇后 #按行dfs 每行有c列种选择；斜线的索引大小，n+n；下标r+c, r-c+N
52. N皇后 如上，只需要返回个数
53. 最大子数组和 #动态规划 #分治 #后序遍历 #前缀和 
54. 螺旋矩阵 #四个变量 #贪心算法 #每次把能打印的都打印
55. 跳跃游戏  #一层for fartest当前能走的最远位置 end当前能走到的终点  step跳几次
56. 合并区间 区间排序可以直接sort
57. 插入区间 #二分 #lower_bound  #upper_bound 注意处理begin_idx = end_idx，直接insert (a.begin() + begin_idx) 否则就需要处理[begin_id, end_idx)的直接取最大小最小即可。
58. 最后一个单词的长度  if (i == N || isspace(s[i])) 得到范围[start, i) 注意前开后闭
59. 螺旋矩阵 每次打印最多即可l, r, u, d 四个变量 l <= r u <= d
60. 排列序列 先算出0~(n-1)的阶乘, 注意要k--。 否则可以试一下当n=2, k=1的时候。然后 idx = k / fac.back(); k %= fac.back();
61. 旋转链表 3次旋转
62. 不同路径  简单的C_{m+n}^{n}
63. 不同路径II 里面有石头 开始位置可能有石头
64. 最小路径和   当前值 = min(上面值，左边值) + `A[r][c]`
65. 有效数字  分治 写两个lambda is_integer(b,e,is_sign,is_empty) is_digit_or_integer
66. 加一  进位
67. 二进制相加 就是整数相加的程序注意：`while (i < alen || j < blen || c)`
68. 文本左右对齐   其实就是写一个printer函数。 #defer 的写法
69. x的平方根 二分
70. 爬楼梯 斐波那契数列
71. 简化路径 字符串分割  #原地处理  回退时先把`ans[to] = 0`; 返回时to == 0，那么返回`'/'`
72. 编辑距离 两个字符串，把`a, b`来当行都可以。但是在字符串匹配里面是把正则表达式用来当行的。
73. 矩阵置零 先记录一下第一行，第一列是否需要变成0。然后再遍历非第一行 && 非第一列的值。如果是0，就把对应的最列上面和最行左边的值设置为0。然后再遍历非第一行，非第一列。如果发现左边/上面为0，设置为0。然后再看第一行&第一列的两个置0变量来设置第一行和第一列。
74. 搜索二维矩阵 找到左下角和右上角的两个点（可访问的点）。大则弃列 && 小则弃行；或者大则弃行 && 小则弃列。然后再按行或按列来二分。
75. 颜色分类  分为三个区间`[0, t0)[t0, t1)[t1 ~ i)` #三路快排
76. 最小覆盖子串  求最小，主动破坏条件  注意`scnt++; if (scnt[x] == t_cnt[x]) hit_cnt++;` 然后在比较的时候，如果`while (hit_cnt >= uniq_cnt_of_t)`
77. 组合 就是从n个数里面选择k个数  #dfs #有一种带栈的写法
	```cpp
		vector<int> st(k);
		int top = 0, val = 1;
		while(top > 0 || top == 0 && val <= n) {
			if(val <= n && top < k) {
				st[top++] = val++;
				if(top == k)
					ans.push_back(st);
			} else
				val = st[--top] + 1;
		}
		return ans;
```

	#dfs有两种写法  #选和不选  #每个位置可以选后面的所有的数字

78. 子集 #dfs #选和不选 #path的每个位置可以选后面所有的数字
79. 单词搜索  #dfs #剪枝 要求每个字母的cnt >= target
80. [80. 删除有序数组中的重复项 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/)  #to变量 #自己当成target #相当于有临时数组
81. [81. 搜索旋转排序数组 II](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/) #要判断 `A[l] == mv || A[r] == mv`的时候，只做l++或者r--。然后利用`if (A[l] < mv)` 来做判断。
82. 删除链表中的重复元素II   #tmp链接
83. [83. 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/) #tmp链接
84. [83. 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/) #尾部对比
85. [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)  #元素左右两边比我小位置
86. 分隔链表  新增两个链表，然后将小于 大于等于的分开放。
87. 扰乱字符串 #3维DP
88. 合并两个有序数组，从后往前合并即可。
89. 格雷码  `i^(i>>1)`
90. [子集 II](https://leetcode.cn/problems/subsets-ii/) #dfs #path_i来做决定  它有几种选择
91. 解码方法  总状态`total`，子状态`end1`和`end2`
92. 反转链表II  分三条链表，一定带哑头
93. 复原IP地址   #dfs 
94. 