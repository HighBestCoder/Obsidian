# [30. 串联所有单词的子串](https://leetcode.cn/problems/substring-with-concatenation-of-all-words/)

#滑动窗口 #一个数组变多个数组 #哈希比较 #超出不计数 #偏序

```C++
class Solution {
public:
    vector<int> findSubstring(string s, vector<string>& words) {
        if (s.empty() || words.empty()) {
            return {};
        }

        unordered_map<string, int> D;
        for (auto &w: words) {
            D[w]++;
        }

        const int L = words[0].length();
        vector<int> ans;

        for (int global_start = 0; global_start < L; global_start++) {
            // ERROR: 要用不常用的变量名，这里不要用start.
            /// 每次都是相当于不同的数组
            unordered_map<string, int> H;
            int start = global_start;
            int hit_cnt = 0;
            for (int i = start; i < s.length(); i += L) {
                // 这个已经不能成为一个单词了
                if (i + L > s.length()) {
                    break;
                }

                /// 取出一个单词
                auto w = s.substr(i, L);

                // 看一下w是不是在D里面
                auto iter = D.find(w);
                // 没有找到
                // 那么双指针的时候，是依据最右原则
                if (iter == D.end()) {
                    H.clear();
                    hit_cnt = 0;   // ERROR1
                    start = i + L; // ERROR2
                    continue;
                }

                assert(D[w] > 0);

                // 如果在D里面
                H[w]++;
                hit_cnt++;

                while (H[w] > D[w]) {
                    // 那么我们要移动前向指针
                    // 然后把前面的都扔掉
                    auto front_word = s.substr(start, L);
                    H[front_word]--;
                    hit_cnt--;
                    start += L;
                }

                assert(hit_cnt > 0);

                if (hit_cnt == words.size()) {
                    ans.push_back(start);
                }
            }
        }

        return ans;
    }
};
```

# 187  重复的dna序列

```Cpp
class Solution {
public:
    vector<string> findRepeatedDnaSequences(string s) {
        unordered_map<string, int> H;
        for (int i = 0; i < s.length(); i++) {
            auto w = s.substr(i, 10);
            if (w.length() == 10) {
                H[w]++;
            }
        }

        std::vector<std::string> ans;
        for (auto &p: H) {
            if (p.second > 1) {
                ans.push_back(p.first);
            }
        }

        return ans;
    }
};
```

#哈希 #计数 #字符串编码 #滚动编码 #双指针 #滑动窗口 #固定长度

```Cpp
class Solution {
public:
    vector<string> findRepeatedDnaSequences(string s) {
        int D[256] = {};

        D['A'] = 0;
        D['C'] = 1;
        D['G'] = 2;
        D['T'] = 3;

        unordered_map<uint32_t, std::pair<int/*cnt*/,int/*index*/>> H;

        uint32_t code = 0;
        int start = -1;
        for (int i = 0; i < s.length(); i++) {
            // 将s[i]添加到code中
            code <<= 2;
            code |= D[s[i]];

            if ((i-start) > 10) {
                // 从code中移除开头的两个bit
                // 即20, 21
                const int mask = ~((1<<20) | (1<<21));
                code &= mask;
                start++;
            }

            if ((i-start) == 10) {
                auto iter = H.find(code);
                if (iter == H.end()) {
                    H[code] = {1/*cnt*/, start + 1/*start_pos*/};
                } else {
                    iter->second.first++;
                }
            }
        }

        std::vector<std::string> ans;
        for (auto &p: H) {
            if (p.second.first > 1) {
                ans.push_back(s.substr(p.second.second, 10));
            }
        }

        return ans;
    }
};
```

# 209 长度最小的子数组

```Cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& A) {
        assert(target > 0);

        const int N = A.size();

        int start = -1;
        uint64_t sum = 0;
        int ans = INT_MAX;

        for (int i = 0; i < N; i++) {
            assert(A[i] > 0);
            sum += A[i];

            while (sum >= target) {
                ans = std::min(ans, i - start);
                sum -= A[start+1];
                start++;
            }
        }

        if (ans == INT_MAX) {
            return 0;
        }

        return ans;
    }
};
```

#最小区间 #双指针 #滑动窗口 #二分

```Cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& A) {
        const int N = A.size();
        if (A.empty()) {
            return 0;
        }

        vector<int> P(N);
        P[0] = A[0];
        for (int i = 1; i < N; i++) {
            P[i] = P[i-1] + A[i];
        }

        assert(N - 1 >= 0);
        if (P[N-1] < target) {
            return 0;
        }

        // 注意：这里[b, e)是两边都是左闭右开
        auto get_sum = [&](const int b, const int e) {
            //printf("b: %d, e:%d\n", b, e);
            assert(0 <= (e-1) && (e-1) < N);
            assert(0 <= b     && b     < N);
            return P[e-1] - P[b] + A[b];
        };

        auto getC = [&](const int len) {
            if (len == 0) { // ERROR 这里为0的时候，直接返回!
	            return 0;
            }
            for (int i = 0; i + len <= N; i++) {
                // 区间为[i, i + len)
                auto s = get_sum(i, i + len);
                if (s >= target) {
                    return 1;
                }
            }

            return 0;
        };

        // 我们要求的是0的uppoer_bound
        int l = 0;
        int r = N;
        while (l < r) {
            const int m = l + ((r-l)>>1);
            const int mov = getC(m);
            if (mov <= 0) {
                l = m + 1;
            } else {
                r = m;
            }
        }

        return l;
    }
};
```


# 220 存在重复元素III
https://leetcode.cn/problems/contains-duplicate-iii/description/
```Cpp
//此行代码开启o3优化默认为o2

#pragma GCC optimize("O3,unroll-loops")

//https://stackoverflowcom/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull
static const auto _ = [](){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    return nullptr;
}();

class Solution {
public:
    bool containsNearbyAlmostDuplicate(vector<int>& A, int k, int64_t valueDiff) {
        std::set<int64_t> H;
        /// 注意，这里的k表示的是下标之差
        /// 那么对应到区间的长度，就是k+1
        /// 所以这里要进行
        k++;

        for (int i = 0; i < A.size(); i++) {
            /// 接下来A[i]要进来
            /// 那么需要保证里面的元素都是
            /// (i-k, i]这个范围的
            /// 那么，此时
            if (i >= k) {
                H.erase(A[i-k]);
            }

            int64_t x = A[i];

            /// 找到 >= x - valueDiff的位置
            auto iter = H.lower_bound(x - valueDiff);
            /// 如果找天，并且它的值
            if (iter != H.end() && *iter <= (x + valueDiff)) {
                return true;
            }

            H.insert(x);
        }

        return false;
    }
};

```

#map #lower_bound #巧妙 利用lower_bound找到(x - valueDiff)然后判断是否小于x + valueDiff就可以知道是否有值在这个区间。

# 239 滑动窗口最大值
https://leetcode.cn/problems/sliding-window-maximum/description/

```Cpp
//此行代码开启o3优化默认为o2

#pragma GCC optimize("O3,unroll-loops")

//https://stackoverflowcom/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull

static const auto _ = [](){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    return nullptr;
}();


class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& A, int k) {
        if (k == 1) {
            return A;
        }

        vector<int> ans;

        /// 这个队列中存放的是下标
        std::deque<int> Q;

        for (int i = 0; i < A.size(); i++) {
            const int x = A[i];

            // 当i要进来的时候，形成的区间应该是
            // (i-k, i]

            // 最大值，使用递减队列
            if (i >= k) {
                while (Q.front() <= (i - k)) {
                    Q.pop_front();
                }
            }

            /// 然后考虑入队
            /// 入队的时候，需要保证队列中的元素是递减的
            /// 不要把相同的值削掉
            while (!Q.empty() && A[Q.back()] < x) {
                Q.pop_back();
            }

            Q.push_back(i);

            if (i >= k - 1) {
                ans.push_back(A[Q.front()]);
            }
        }

        return ans;
    }
};
```

#滑动窗口  #单调队列 #单调队列有重复 #定长区间

# 395. 至少有 K 个重复字符的最长子串
[395. 至少有 K 个重复字符的最长子串](https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/)

```Cpp
//此行代码开启o3优化默认为o2

#pragma GCC optimize("O3,unroll-loops")

//https://stackoverflowcom/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull

static const auto _ = [](){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    return nullptr;
}();

class Solution {
public:
    int longestSubstring(string s, int k) {
        int ans = 0;

        int C[26] = {};
        for (int i = 0; i < s.length(); i++) {
            C[s[i]-'a'] = 1;
        }

        int SUM = 0;
        for (int i = 0; i < 26; i++) {
            SUM += C[i];
        }

        for (int num = 1; num <= SUM; num++) {
            int start = -1;
            int H[26] = {};
            int hit_cnt = 0;
            int le_k = 0;

            for (int i = 0; i < s.length(); i++) {
                // (start, i]
                // 要成一个区间
                const int idx = s[i] - 'a';

                H[idx]++;
                hit_cnt += H[idx] == 1;
                le_k += H[idx] == k;

                while (start < i && hit_cnt > num) {
                    // 这里要把start + 1扔出去
                    const int idx = s[start + 1] - 'a';
                    hit_cnt -= H[idx] == 1;
                    le_k -= H[idx] == k;
                    H[idx] -= 1;
                    start += 1;
                }

                assert(hit_cnt <= num);

                if (le_k == num) {
                    assert(hit_cnt == num);
                    ans = max(ans, i - start);
                }
            }
        }

        return ans;
    }
};
```

#分治 #有趣切分 #两个条件 #哈希条件

这里有趣的地方是使用了两个条件，我们固定了其中一个条件。这个固定的条件可以用来卡住滑动窗口。

哈希表这里我们用了数组，然后分别在进入和退出的地方设置了门槛。

# 424. 替换后的最长重复字符
[424. 替换后的最长重复字符](https://leetcode.cn/problems/longest-repeating-character-replacement/)

```C++
class Solution {
public:
    int characterReplacement(string s, int k) {
        int start = -1;
        int H[26] = {};

        int ans = 0;
        int max_cnt = 0;

        for (int i = 0; i < s.length(); i++) {
            const int idx = s[i] - 'A';
            H[idx]++;
            max_cnt = max(max_cnt, H[idx]);

            while (start < i && ((i-start) - max_cnt) > k) {
                const int idx = s[start + 1] - 'A';
                H[idx]--;
                start++;
            }

            ans = std::max(ans, i - start);
        }

        return ans;
    }
};
```

#退出不用减 #最大值统治其他值  #贪心
这里移动start的时候，不去更新max_cnt，这是因为，如果移动start会导致真正的max_cnt减少。
那么，在这种情况下，其解不会比旧的max_cnt(没减少的)这种情况下的解更优。


# 438. 找到字符串中所有字母异位词
[438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

```Cpp
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        int D[26] = {};
        for (int i = 0; i < p.length(); i++) {
            D[p[i]-'a']++;
        }
        int K = 0;
        for (int i = 0; i < 26; i++) {
            K += D[i] != 0;
        }

        int H[26] = {};
        int hit_cnt = 0;
        int start = -1;

        vector<int> ans;

        for (int i = 0; i < s.length(); i++) {
            const int idx = s[i] - 'a';
            // 因为s[i]要进来
            // (start, i]
            if ((i-start) > p.length()) {
                const int x = s[start + 1] - 'a';
                hit_cnt -= H[x] == D[x];
                H[x]--;
                start++;
            }

            H[idx]++;
            hit_cnt += H[idx] == D[idx];

            if (hit_cnt == K) {
                ans.push_back(start + 1);
            }
        }

        return ans;
    }
};
```
#哈希相等 #滑动窗口 #门槛进出

# 567. 字符串的排列
[567. 字符串的排列](https://leetcode.cn/problems/permutation-in-string/)

```Cpp
class Solution {
public:
    bool checkInclusion(string s1, string s2) {
        if (s1.length() > s2.length()) {
            return false;
        }

        int D[26] = {};
        for (auto c: s1) {
            D[c-'a']++;
        }

        int start = -1;
        int hit_cnt = 0;
        int H[26] = {};

        for (int i = 0; i < s2.length(); i++) {
            // (start, i-1]
            // 那么看一下是不是已经有s2那么长了
            if ((i - 1 - start) >= s1.length()) {
                // 删除start + 1
                const int idx = s2[start+1] - 'a';
                hit_cnt -= H[idx] <= D[idx];
                H[idx]--;
                start++;
            }

            const int idx = s2[i] - 'a';
            H[idx]++;
            hit_cnt += H[idx] <= D[idx];

            if (hit_cnt == s1.length()) {
                return true;
            }
        }

        return false;
    }
};
```

#滑动窗口 #定长区间 #固定长度 #哈希比较 #哈希相等 


# 632. 最小区间
[632. 最小区间](https://leetcode.cn/problems/smallest-range-covering-elements-from-k-lists/)

```Cpp
class Solution {
public:
    vector<int> smallestRange(vector<vector<int>>& A) {

        struct Node {
            int val;
            int idx;
            int arr;
            bool operator < (const Node &b) const {
                return val < b.val;
            }

            bool operator == (const Node &b) const {
                return val == b.val && arr == b.arr;
            }

            Node() {
                val = idx = arr = 0;
            }

            Node(int v, int i, int ar) {
                val = v;
                idx = i;
                arr = ar;
            }
        };

        multiset<Node> S;

        // 首先要把所有的元素都放进去
        const int K = A.size();
        for (int i = 0; i < K; i++) {
            if (!A[i].empty()) {
                Node t{A[i][0], 0, i};
                S.insert(t);
            }
        }

        vector<int> ans{0,-1};
        int min_diff = INT_MAX;

        while (!S.empty()) {
            if (S.size() == K) {
                const int diff = S.rbegin()->val - S.begin()->val;
                if (diff < min_diff) {
                    min_diff = diff;
                    ans[0] = S.begin()->val;
                    ans[1] = S.rbegin()->val;
                }
            }

            auto p = *S.begin();
            S.erase(S.begin());

            if (p.idx + 1 < A[p.arr].size()) {
                Node t { A[p.arr][p.idx+1], p.idx + 1, p.arr };
                S.insert(t);
            }
        }

        return ans;
    }
};
```

#合并排序 #堆的最小间距 

```Cpp
class Solution {
public:
    vector<int> smallestRange(vector<vector<int>>& A) {
        unordered_map<int,vector<int>> H;
        for (int i = 0; i < A.size(); i++) {
            for (auto x: A[i]) {
                H[x].push_back(i);
            }
        }

        vector<int> V;
        for (auto &p: H) {
            V.push_back(p.first);
        }

        sort(V.begin(), V.end());

        vector<int> C(A.size(), 0);

        int start = -1;
        int hit_cnt = 0;
        vector<int> ans{0,-1};
        int min_diff = INT_MAX;

        for (int i = 0; i < V.size(); i++) {
            auto &color = H[V[i]];
            // 都染上色
            for (auto &idx: color) {
                if (C[idx] == 0) {
                    hit_cnt++;
                }
                C[idx]++;
            }

            // 要求最小范围
            while (start < i && hit_cnt == A.size()) {
                // 当前的区间是(start, i]
                // 取最优值
                int diff = V[i] - V[start+1];
                if (diff < min_diff) {
                    min_diff = diff;
                    ans[0] = V[start+1];
                    ans[1] = V[i];
                }

                // 破坏约束
                const int x = V[start+1];
                auto &color = H[x];
                for (auto idx: color) {
                    if (C[idx] == 1) {
                        hit_cnt--;
                    }
                    C[idx]--;
                }

                start++;   // ERROR 注意移动指针
            }
        }

        return ans;
    }
};
```

#最小区间 #染色问题 #颜色珠子

# 643. 子数组最大平均数 I

```Cpp
class Solution {
public:
    double findMaxAverage(vector<int>& A, int k) {
        int start = -1;
        double ans = INT_MIN;
        double temp_sum = 0;
        for (int i = 0; i < A.size(); i++) {
            // (start, i-1]
            if ((i-1-start) >= k) {
                // 删除开头的数字
                temp_sum -= A[start+1];
                start++;
            }

            // 将A[i]添加到区间
            temp_sum += A[i];

            double temp_ans = temp_sum / (double)k;
            if ((i-start) == k && temp_ans > ans) {
                ans = temp_ans;
            }
        }

        return ans;
    }
};
```

#定长区间  #固定长度 #平均值

# 658. 找到 K 个最接近的元素

[658. 找到 K 个最接近的元素](https://leetcode.cn/problems/find-k-closest-elements/)

```Cpp
class Solution {
public:
    vector<int> findClosestElements(vector<int>& A, int k, int x) {
        // 最接近X的数
        auto idx = lower_bound(A.begin(), A.end(), x) - A.begin();

        std::vector<int> ans;
        int l = idx;
        int r = idx + 1;

        // 这里要做个处理，就是当发现A[l] > x的时候，实际上是需要退一步的
        if (l < A.size() && A[l] > x) {
            l = idx - 1;
            r = idx;
        }

        while (ans.size() < k) {
            int64_t lv = INT64_MIN;
            if (0 <= l && l < A.size()) {
                // 左边有值可以取
                lv = A[l];
            }
            int64_t rv = INT64_MIN;
            if (0 <= r && r < A.size()) {
                rv = A[r];
            }

            // 两边都没有值
            if (lv == rv && lv == INT64_MIN) {
                /// 如果左边还有值
                if (0 < l) {
                    l--;
                } else {
                    // 如果右边还有值
                    r++;
                }

                continue;
            }

            // 有一边有值，那就就取那边
            if (lv == INT64_MIN && rv != INT64_MIN) {
                // 取rv
                ans.push_back(rv);
                r++;
                continue;
            }
            if (lv != INT64_MIN && rv == INT64_MIN) {
                ans.push_back(lv);
                l--;
                continue;
            }

            // 如果两边都有值
            // 看谁的绝对值更小
            if (std::abs(x - lv) <= std::abs(rv - x)) {
                ans.push_back(lv);
                l--;
            } else if (std::abs(x - lv) > std::abs(rv - x)) {
                ans.push_back(rv);
                r++;
            }
        }

        sort(ans.begin(), ans.end());

        return ans;
    }
};
```

#合并排序 #lower_bound

